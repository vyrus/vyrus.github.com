Описание архитектуры
====================

Здесь представлено описание взаимодействия частей системы в процессе обработки
запроса.

Шаг 1
-----
    
![Шаг 1](/images/arch-step-1.png)
    
На первом шаге создаётся экземпляр менеджера ресурсов. Он предназначен для 
инициализации и обращения к различным активным элементами архитектуры (для 
простоты будем называть их ресурсами). Причём реальные экземпляры ресурсов 
создаются лишь в момент первого обращения к ним, а в дальнейшем ссылка на этот 
экземпляр сохраняется в менеджере. Таким образом реализуется механизм поздней 
загрузки, одновременно остающийся прозрачным для других частей системы и 
инкапсулированный внутри одной абстракции.

При создании менеджеру ресурсов передаётся конфигурация системы, то есть 
параметры настройки, влияющие на поведение системы в конкретном рабочем 
окружении. Перечислим эти параметры:

* режим работы системы;

    позволяет выбирать режим функционирования системы: в режиме отладки или в 
    рабочем режиме. Первый используется в процессе разработки - он позволяет 
    выявлять ошибки в коде, отображая отладочную информацию о процессе работы 
    системы (дерево вызовов, аргументы функций и методов и т.д.). Во втором 
    режиме отладочная информация не отображается пользователям системы 
    (поскольку её раскрытие посторонним с точки зрения безопасности 
    функционирования сервера недопустимо), но записывается в специальный файл 
    журнала, которой впоследствии может быть проанализирован системным 
    администратором.

* адрес сайта;

    базовый адрес сайта, который будет в дальнейшем использоваться системой при 
    генерации ссылок на сайте и в почтовых сообщениях, отправляемых 
    пользователям.
    
* настройки соединения с базой данных;
    
    сюда входят такие параметры, как СУБД, с которой будет осушествляться 
    работа, адрес сервера, имя пользователя, пароль. Допольнительно могут быть 
    указаны опции, специфичные для какой-либо конкретной СУБД.
    
* маршруты;

    маршруты позволяют связывать запросы к веб-серверу с их непосредственными 
    обработчиками в коде разрабатываемого приложения.

* права доступа пользователей;

    в зависимости от ролей пользователей в системе они имеют доступ к 
    определённому набору страниц. Этот параметр служит для установления 
    ассоциаций между ролями пользователей и обработчиками запросов (парами 
    "контроллер-действие"), к которым пользователю разрешён доступ.
        
* строка для шифрования данных авторизации;
    
    пароли пользователей и некоторая другая информация, являющаяся 
    чувствительной с точки зрения безопасности, сохраняется в базе с помощью 
    необратимого алгоритма шифрования (хеширования), чтобы в случае, если 
    потенциальный злоумышленник сможет считать такого рода информацию из базы 
    данных, он не получил полного контроля над учётными записями пользователей. 
    Для усиления хеш-функции применяется строка, состоящая из случайных 
    символов, привносящая дополнительные степень неопределённость и, 
    следовательно, стойкость к перебору в получаемые хеши.

* настройки отправки почтовых сообщений.

    в процессе работы с системой пользователям могут отправляться электронные 
    почтовые сообщения. Данный параметр задаёт такие настройки, как используемый
    для отправки транспорт (локальный агент передачи почты или удалённый 
    SMTP-сервер), адрес и имя отправителя, данные для авторизации на 
    SMTP-сервере (если выбран соответствующий транспорт).

В целом, менеджер ресурсов представляет собой реализацию одной из форм активной 
инверсии зависимостей в коде, используемых при построении 
объектно-ориентированных систем. Эта форма называется "dependency lookup: pull 
approach" и предполагает наличие в системе общедоступного объекта, который 
знает обо всех используемых сервисах. Таким образом все зависимости 
инкапсулируются внутри этого объекта, и остальные части системы могут 
запрашивать по мере необходимости доступ к сервисам через него. [[1]]
[agiledev]

Шаг 2
-----
    
![Шаг 2](/images/arch-step-2.png)

На втором шаге создается экземпляр диспетчера запросов. Его предназначение 
состоит в том, чтобы при помощи маршрутизатора и сервиса авторизации 
делегировать управление необходимому в данный момент обработчику. Посколько 
система построена с использованием парадигмы MVC, то обработчиками запросов в 
данном случае выступают контроллеры, а точнее отдельные их действия.

    @todo Добавить ссылку на спеки HTTP.

Также диспетчер выполняет обработку ошибочных ситуаций, когда обработчик для 
текущего запроса не найден (код ошибки HTTP 404 - страница не найдена) и когда 
доступ текущему пользователю к обработчику запрещён (код ошибки 403 - доступ 
запрещён). В таких случаях управление будет передано специализированному 
контроллеру.

Шаг 3
-----
    
![Шаг 3](/images/arch-step-3.png)

Создаётся контейнер, содержащий практически всю информацию о запросе к 
веб-серверу. Сюда входят данные, переданные браузером пользователя 
HTTP-методами GET и POST, cookie (небольшие фрагменты данных, созданные
веб-сервером и хранимые на компьютере пользователя в виде файла, который 
веб-клиент, обычно веб-браузер, каждый раз пересылает веб-серверу в 
HTTP-запросе при попытке открыть страницу соответствующего сайта 
[[2]][cookie-wiki]) и переменные окружения веб-сервера. Такой контейнер создаёт 
дополнительный слой абстракции для системы, позволяя собрать зависимости 
различных частей от глобальных переменных, содержащих данные о запросе, в одной 
и поэтому легко контролируемой сущности. И этот контейнер передаётся для 
обработки диспетчеру запросов.

Шаг 4
-----
    
![Шаг 4](/images/arch-step-4.png)

На четвёртом шаге порождается экземпляр маршрутизатора, задачей которого 
является поиск среди настроенных в конфигурационных данных маршрута, шаблон 
которого совпадает с текущей запрашиваемой страницей, и определение 
необходимого обработчика.

Маршрут состоит из следующих полей данных:

* алиас;

    краткое обозначение маршрута, используемое при генерации ссылок менеджером 
    ссылок в коде контроллеров и шаблонов.
    
* тип;

    маршруты могут быть двух типов. Маршруты первого типа, статичные, задают 
    однозначное соответствие между конкретным запрашиваемым адресом и 
    соответствующмм обработчиком для него. Маршруты же второго типа, на основе 
    регулярных выражений, позволяют дополнительно выделять из строки запроса 
    отдельные параметры, передаваемые впоследствии контроллеру. Регулярные 
    выражения - это формальный язык поиска и осуществления манипуляций с 
    подстроками в тексте, основанный на использовании метасимволов (англ. 
    wildcard characters). По сути это строка-образец (англ. pattern, по-русски 
    её часто называют «шаблоном», «маской»), состоящая из символов и 
    метасимволов и задающая правило поиска. [[3]][regex-wiki]

* шаблон;

    для маршрутов первого типа это строка, задающая точное значение 
    запрашиваемого адреса, а для маршрутов второго - регулярное выражение и 
    список названий для выделяемых параметров.
    
* обработчик;

    задаёт пару "контроллер-действие", которая будет выполнять непосредственную 
    работу по выполнению запроса пользователя.

* параметры.

    для каждого марщрута (статического или с регулярным выражением) можно 
    вручную задавать дополнительные параметры, которые будут передавать в 
    обработчик.

Шаг 5
-----
    
![Шаг 5](/images/arch-step-5.png)

Диспетчер запросов проверяет, закрыт ли публичный доступ к запрашиваемой 
странице, и если да, то у менеджера ресурсов запрашивается ссылка на экземпляр 
сервис авторизации. С помощью него проверяется, авторизован ли пользователь в 
системе и какие права на доступ ему предоставлены. Если прав недостаточно для 
запрашиваемой странице, то диспетчер передаст управление не целевому 
контроллеру, а специализированному для обработки ошибки запрета доступа, который
выведет соответствующее сообщение об ошибке и предложит пользователю пройти 
авторизацию (если он не авторизован).

Сервис авторизации работает на основе механизма сессий. Cессии - это механизм, 
который позволяет создавать и использовать переменные, сохраняющие свое 
значение в течение всего времени работы пользователя с сайтом.

Эти переменные для каждого пользователя имеют различные значения и могут 
использоваться на любой странице сайта до выхода пользователя из системы. При 
этом каждый раз, заходя на сайт, пользователь получает новые значения 
переменных, позволяющие идентифицировать его в течение этого сеанса или сессии 
работы с сайтом. Отсюда и название механизма - сессии.

Задача идентификации пользователя решается путем присвоения каждому 
пользователю уникального номера, так называемого идентификатора сессии (SID, 
Session IDentifier). Он генерируется PHP в тот момент, когда пользователь 
заходит на сайт, и уничтожается, когда пользователь уходит с сайта, и 
представляет собой строку из 32 символов (например, 
ac4f4a45bdc893434c95dcaffb1c1811). Этот идентификатор передается на сервер 
вместе с каждым запросом клиента и возвращается обратно вместе с ответом 
сервера.

Алгоритм генерации SID (а в PHP в качестве идентификатора сессии используется 
т.н. GUID (Global Unique IDentifier)) позволяет гарантировать его уникальность, 
поэтому исключена возможность того, что две сессии будут иметь один и тот же 
идентификатор сессии.

Существует несколько способов передачи идентификатора сессии:

* с помощью cookies;

    cookies были созданы специально как метод однозначной идентификации 
    клиентов и представляют собой расширение протокола HTTP. В этом случае 
    идентификатор сессии сохраняется во временном файле на компьютере клиента, 
    пославшего запрос. Однако, многие пользователи отключают поддержку cookies 
    на своем компьютере из-за проблем с безопасностью.

* с помощью параметров командной строки.
    
    в этом случае идентификатор сессии автоматически встраивается во все 
    запросы (URL), передаваемые серверу, и хранится на стороне сервера. Этот 
    способ передачи идентификатора используется автоматически, если у браузера, 
    отправившего запрос, выключены cookies. Он достаточно надежный - передавать 
    параметры в командной строке можно всегда. С другой стороны, идентификатор 
    сессии можно украсть, воспользоваться сохраненным вариантом в строке 
    браузера или попытаться подделать.
    
[[7]][sessions-1], [[8]][sessions-2]

Шаг 6
-----
    
![Шаг 6](/images/arch-step-6.png)

После определения обработчика и проверки прав доступа диспетчер загружает код 
соответствующего класса контроллера и создаёт его экземпляр. После чего 
вместе со списком параметров передаёт управление одному из его методов, 
реализующих запрошенное действие.

Шаг 7
-----
    
![Шаг 7](/images/arch-step-7.png)

Контроллер выполняет запрошенное действие. В процессе он может инициализировать 
нужные модели и обращаться к ним. Модели служат для представления 
предметно-ориентированных данных и манипулирования ими. Основная их работа 
связана с объектом взаимодействия с базой данных, ссылку на которой они 
получают через менеджер ресурсов.

Объект для работы с базой данных основан на PHP Data Objects (PDO) — расширении 
для PHP, предоставляющее разработчику простой и универсальный интерфейс для 
доступа к различным базам данных.

PDO предлагает единые методы для работы с различными базами данных, хотя текст 
запросов может немного отличаться. Так как многие СУБД реализуют свой диалект 
SQL, который в той или иной мере поддерживает стандарты ANSI и ISO, то при 
использовании простых запросов можно добиться совместимости между различными 
языками. На практике это означает, что можно достаточно легко перейти на другую 
СУБД, при этом не меняя или частично изменяя код программы.

PDO не использует абстрактных слоёв для подключения к БД, наподобие ODBC, а 
использует для разных БД их «родные» драйверы, что позволяет добиться высокой 
производительности. В настоящее время для PDO существуют драйверы практически 
ко всем общеизвестным СУБД и интерфейсам. Впрочем, есть и драйвер для 
подключения к ODBC. 

Также контроллер может создавать и работать с экземплярами вспомогательных 
классов, которые упрощают взаимодействие с HTML-формами.

Формы позволяют вводить текст, осуществлять выбор из предложенных значений при 
помощи списков или кнопок. С помощью форм можно организовать интерактивный 
обмен информацией между Web-страницей и сервером. Можно определить формы как 
электронные бланки для заполнения различных данных таких как, например, имя, 
возраст, выбор страны проживания и других. Как правило, форма работает 
совместно с установленным на сервере сценарным приложением, обрабатывающим 
введенную информацию. [[6]][forms]

Шаг 8
-----
    
![Шаг 8](/images/arch-step-8.png)

Помимо взаимодействий с моделями и обработчиками форм, контроллер может 
обращаться к сервису авторизации для получения данных текущего пользователя и 
реализации на их основе дополнительной логики обработки запросов.

А также контроллер может использовать менеджер ссылок. Он позволяет получать 
ссылки на различные страницы системы на основе данных маршрутов. Обращаясь к 
специальному методу менеджера ссылок и передавая ему алиас маршрута (для 
маршрутов на основе регулярных выражений может понадобиться ещё и передача 
списка значений параметров), можно получить ссылку на необходимую страницу, 
которая будет сформирована с учётом настроек системы. Таким образом, 
достигается гибкость системы в отношении её установки на сервере - все ссылки 
могут автоматически подстраиваться под рабочее окружение. Кроме того, сочетание 
маршрутов и использования в коде менеджера ссылок даёт возможность построения 
иерархии удобных и понятных адресов страниц на сайте.

Шаг 9
-----
    
![Шаг 9](/images/arch-step-9.png)

После завершения работы контроллер запрашивает у менеджера ресурсов объект 
представления, который занимается сборкой шаблонов, и ему передаётся управление 
вместе с набором переменных, который был сформирован во время выполнения 
действия контроллера и содержит необходимые для успешной обработки шаблонов 
данные.

После чего происходит сборка шаблонов трёх уровней и выдача пользователю 
сформированной страницы. К первому уровню относятся шаблоны страниц, 
ассоциированные с конкретными действиями запрошенного контроллера. На втором - 
шаблоны элементов, то есть частей страниц, которые повторяются в нескольких 
других шаблонах и поэтому могу быть выделены в отдельные файлы. И на третьем 
уровне - шаблон макета, содержащий общие для всех страниц части и выдача 
пользователю сформированной страницы.

Шаг 10
-----
    
![Шаг 10](/images/arch-step-10.png)

В процессе обработки шаблонов могут, как и в случае работы контроллеров, 
вызываться (через менеджер ресурсов) менеджер ссылок и объекты обработчиков 
форм, которые являются источниками необходимых для сборки выходных страниц 
данных.

Литература
----------
1. [Инверсия зависимостей при проектировании Объектно-Ориентированных систем]
   [agiledev] 
2. [HTTP Cookie][cookie-wiki]
3. [Регулярные выражения][regex-wiki]
4. [PDO: Introduction][pdo-php]
5. [PHP Data Objects][pdo-wiki]
6. [Формы][forms]
7. [Механизм сессий][sessions-1]
8. [Удобная штука - сессии][sessions-2]

[agiledev]: http://wiki.agiledev.ru/doku.php?id=ooad:dependency_injection "Инверсия зависимостей при проектировании Объектно-Ориентированных систем"    
[cookie-wiki]: http://ru.wikipedia.org/wiki/HTTP_cookie "HTTP Cookie"
[regex-wiki]: http://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D0%B3%D1%83%D0%BB%D1%8F%D1%80%D0%BD%D1%8B%D0%B5_%D0%B2%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F "Регулярные выражения"
[pdo-php]: http://www.php.net/manual/en/intro.pdo.php "PDO: Introduction"
[pdo-wiki]: http://ru.wikipedia.org/wiki/PHP_Data_Objects "PHP Data Objects"
[forms]: http://doc.olspire.com/HTML/Formy "Формы"
[sessions-1]: http://www.znannya.org/?view=PHP_sessions_mechanic "Механизм сессий"
[sessions-2]: http://www.providerz.ru/articles/php/sessions.html "Программирование на PHP. Четвертый выпуск."