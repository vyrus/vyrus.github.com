<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
 
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
    <title>GitHub Pages - Home</title>
    <link href="/stylesheets/bundle_common.css" media="screen" rel="stylesheet" type="text/css" />
    <link href="/stylesheets/bundle_github.css" media="screen" rel="stylesheet" type="text/css" />
    <link href="/stylesheets/screen.css" media="screen" rel="stylesheet" type="text/css" />
  </head>
  <body>
    <div id="main">
      <div id="header" class="basic">
 
        <div class="site">
          <div class="logo">
            <a href="/"><img src="/images/modules/header/logo_pages.png" alt="github pages" /></a>
          </div>
          <div class="actions">
            <a href="http://github.com">home</a>
            <a href="http://github.com/login">login</a>
            <a href="http://github.com/signup">signup!</a>
          </div>
        </div>
      </div>
 
      <div id="content" class="site">
      <div class="wikistyle">
        <h1>Текст доклада</h1>

<h2>1. Титульный слайд</h2>

<h2>2. Цели и задачи работы</h2>

<p>Дистанционное обучение − совокупность технологий, обеспечивающих доставку 
обучаемым основного объёма изучаемого материала, интерактивное взаимодействие 
обучаемых и преподавателей в процессе обучения, предоставление обучаемым 
возможности самостоятельной работы по освоению изучаемого материала.
В настоящее время перспективным является интерактивное 
взаимодействие с учащимися посредством информационных коммуникационных сетей.</p>

<p>Сегодня дистанционное обучение стало более чем реальной альтернативой 
традиционному. Интернет даёт возможность все большему числу заинтересованных 
людей получать доступ к информации и носителям знаний, независимо от места 
нахождения. Тем более, что с каждым годом стоимость обмена информацией в 
глобальной сети уменьшается, и эта услуга становится доступной гораздо большему 
числу пользователей.</p>

<p>Переход высшей школы на образовательные стандарты следующего поколения 
предполагает увеличение самостоятельной работы студентов, и именно дистанционные 
технологии помогут решить эту проблему. В связи с принятием Болонского 
соглашения (переход на двухуровневую систему образования) всё большую роль будет 
играть повышение квалификации и переподготовка специалистов по узким 
направлениям на базе бакалавриата, который является первой ступенью для 
получения высшего профессионального образования. В решении данной 
проблемы дистанционное образование является одним из самых эффективных решений.</p>

<p>Актуальность разработки определяется всё более широким распространением 
технологий дистанционного обучения, необходимостью регулярного обновления знаний 
специалистами различных категорий, востребованностью программ профессиональной 
переподготовки и повышения квалификации в современных условиях.</p>

<p>В то же время, в АНО «Центр Интернет-образования» накоплен 
значительный опыт ведения образовательной деятельности по программам 
дополнительного профессионального образования и сформирована обширная база 
учебно-методических материалов. Это позволяет ставить задачу реализации обучения 
слушателей в заочной (дистанционной) форме.</p>

<h2>3. Описание предметной области</h2>

<p>Перед тем как приступить к проектированию системы дистанционного обучения, необходимо ознакомиться и проанализировать предметную область.
Для начала, введем набор базовых понятий предметной области и далее будем оперировать ими.
Слушатель (пользователь) – обучаемый, человек, проходящий обучение. При этом слушатель может обучаться по программе профессиональной переподготовки, по отдельной дисциплине, может обучаться на так называемых краткосрочных курсах.
Преподаватель – педагогический работник, непосредственно осуществляющий учебный процесс по какой-либо дисциплине или по ряду дисциплин.
Куратор – преподаватель, осуществляющий общий контроль за процессом обучения конкретного слушателя. Куратор назначается только в случае обучения по программе профессиональной переподготовки.
Администратор – сотрудник, в процессе обучения выполняющий организационные функции.
Курсы – образовательная программа, предполагающая изучение определенного круга взаимосвязанных вопросов по некоторой теме. Общий объем учебных часов по курсам относительно невелик. Примеры: «Компьютерная графика и дизайн», «Администрирование операционной системы Linux». Курсы могут быть платными и бесплатными.
Направление подготовки – образовательная программа (программа профессиональной переподготовки), предполагающая более длительное обучение с получением профессиональных компетенций. Учебный процесс в данном случае напоминает учебный процесс в ВУЗе: изучаемый материал поделен на дисциплины, по которым предусмотрен итоговый контроль знаний (зачет, экзамен, курсовая работа).
Дисциплина – составляющая образовательной программы. Изучение дисциплины предполагает изучение вопросов по определенного круга взаимосвязанных вопросов по некоторой теме. Например, «Состав и устройство персонального компьютера», «Основы баз данных», «Алгоритмические языки и основы программирования». В соответствии с одним из ключевых положений дистанционного обучения дисциплина может изучаться слушателем отдельно, в отрыве от общей программы, т.е. если человека интересуют лишь две дисциплины из десяти, включенных в направление подготовки, то он может выбрать их и изучать. В случае изучения полного набора дисциплин в рамках какого-либо направления подготовки, слушатель считается освоившим это направление.
Дисциплины, входящие в одну образовательную программу, могут быть определены как взаимосвязанные. В таком случае к изучению очередной дисциплины слушатель может приступить, только пройдя итоговый контроль по предшествующей/предшествующим дисциплинам.
Материал дисциплины может быть поделен на разделы. В таком случае слушатель получает доступ к материалам следующего раздела только после того, как им пройдена «контрольная точка» по предыдущему разделу.
Учебный материал – совокупность теоретических сведений, практических и лабораторных заданий, вспомогательных файлов, оформленных в электронном варианте, и используемых слушателем для получения знаний, навыков, компетенций.
«Контрольная точка» – процесс выполнения слушателем контрольных (отчетных) заданий по разделу дисциплины. «Контрольная точка» может включать выполнение лабораторной работы, контрольной работы, тестового задания. В общем случае «контрольная точка» может включать как все три вида работ, так и один или два из них. Характеристикой множественной «контрольной точки» связанность ее элементов. Если элементы «контрольной точки» не связаны, то слушатель может выполнять работы в любом порядке (например, сначала тест, потом – лабораторную работу, или наоборот). Если же элементы связаны, то выполнять их требуется в порядке, определенном преподавателем (например, сначала тест, потом – лабораторная). Результат выполнения тестовых заданий формируется системой автоматически. Выполнение контрольных и лабораторных работ оценивается преподавателем.
Итоговый контроль включает мероприятия, направленные на оценку знаний и навыков слушателя по итогам изучения дисциплины (зачет, экзамен, курсовая работа). Состав и форма мероприятий по конкретной дисциплине определяется учебным планом направления подготовки. В подсистеме итоговый контроль реализуется как самостоятельный раздел, либо же вовсе выносится на рамки системы и проводится в традиционной форме (зачет, экзамен, защита курсовой работы).
Исходя из наличия нескольких групп пользователей, можно выделить, соответственно несколько точек зрения  на разрабатываемую систему.
Рассмотрим систему с точки зрения слушателя. Одним из самых выразительных средств иллюстрации процессов являет нотация диаграмм IDEF0. Контекстная диаграмма процессов предметной области представлена на рисунке 1.</p>

<p>Рисунок 1 − Контекстная диаграмма процессов предметной области
Детализация контекстной диаграммы представлена на рисунке 2.</p>

<p>Рисунок 2 − Детализация контекстной диаграммы</p>

<p>Детализируем активность «Пройти обучение на бесплатных курсах». Соответствующая диаграмма представлена на рисунке 3.</p>

<p>Рисунок 3 − Детализация активности «Пройти обучение на бесплатных курсах»</p>

<p>Детализация активностей «Пройти обучение (платное)» и «Изучить дисциплины, входящие в учебный план» представлены на рисунках 4 и 5 соответственно.</p>

<p>Рисунок 4 − Детализация активности «Пройти обучение (платное)»</p>

<p>Рисунок 5 − Детализация активности « Изучить дисциплины, входящие в учебный план»</p>

<p>Прокомментируем в нескольких словах представленные диаграммы.
Пользователю, прошедшему первичную регистрацию должен быть предоставлен перечень бесплатных курсов, платных курсов, направлений подготовки и дисциплин, включаемых в каждое направление. Должна быть обеспечена возможность отправить заявку на обучение на платных курсах, направлениях, дисциплинах; а также возможность приступить к обучению по бесплатным курсам.
Раскроем несколько подробней процесс изучения дисциплины. Сначала пользователь получает доступ (в случае, если изучены предшествующие дисциплины и достаточно внесенной оплаты) к материалам раздела, скачивает их, изучает. Если в процессе этого возникают вопросы, слушатель может задать их преподавателю данной дисциплины, закрепленному за данным слушателем. Также слушатель имеет возможность обмена файлами с преподавателем. В тот момент, когда слушатель готов к выполнению контрольного задания, он получает их и выполняет. В случае успешного прохождения «контрольной точки» слушатель получает доступ к материалам следующего раздела дисциплины или может приступить к прохождению итогового контроля (если изученный раздел был заключительным). Если попытка преодолеть «контрольную точку» оказалась неудачной, слушатель возвращается к изучению материалов, и через некоторое время может предпринять новую попытку.
Следует учесть, что при выборе слушателем для изучения отдельной дисциплины процесс ничем не отличается от описанного. Но следует отметить, что отсутствуют взаимосвязи и переходы между дисциплинами.
С точки зрения преподавателя, в системе можно выделить следующие процессы:
1)    наполнение системы материалами;
2)    ведение учебного процесса (консультации слушателей);
3)    осуществление контрольных мероприятий в рамках разделов дисциплин;
4)    проведение итоговых контрольных мероприятий по дисциплинам.
В обязанности администратора входят:
1)    регистрация в системе новых преподавателей;
2)    формирования иерархии курсов и направлений/дисциплин/разделов и закрепление за дисциплинами ответственных преподавателей;
3)    закрепление за студентами ответственных преподавателей − кураторов;
4)    зачисление/отчисление слушателей;
5)    работа с заявками слушателей и договорами на обучение.
Рассмотрим несколько более подробно процесс работы с заявками.
В момент отправки слушателем заявки на обучение (вторичной регистрации) он указывает паспортные данные, сведения об имеющемся образовании, контактный телефон. Далее администратор рассматривает заявку и, если заявка принята, то администратор указывает это, изменяя таким образом статус слушателя. В результате слушателю становится доступен договор для скачивания, копия отсылается на e-mail. Если результат рассмотрения заявки отрицателен – слушателя отказано, то администратор отправляет ему e-mail, в котором излагается причина отказа.
Следующий этап − подписанный слушателем договор поступает в организацию, использующую систему. Администратор меняет статус слушателяи с этого момента для него формируется квитанции для оплаты. Они, опять же, доступны для скачивания или отправляются по e-mail.
Следующий этап − изучение банковских выписок и внесение величины оплаты по конкретному слушателю, меняется статус слушателя, в результате чего он получает доступ к материалам и может начинать обучение.</p>

<h2>4. Концептуальная схема базы данных</h2>

<p>Структура базы данных поделена на 5 слоёв:</p>

<ol>
<li>пользователи;</li>
<li>регионы;</li>
<li>сообщения;</li>
<li>заявки;</li>
<li>учебные программы.</li>
</ol>

<p>Слой пользователей (рисунок &#95;&#95;PIC&#95;DB&#95;LAYER&#95;USERS&#95;&#95;) состоит из 
четырёх сущностей: «Пользователи», «Паспорта», «Документы об образовании» и 
«Телефоны». Первая отвечает за хранение базовой информации о пользователях, 
такой как логин, пароль, роль пользователя, адрес электронной почты и др. В 
остальных трёх сущностях содержатся данные расширенного профиля пользователя – 
информация о паспортных данных, документах об образовании и телефонных номерах.</p>

<p><img src="/images/db-layer-users.png" alt="Слой пользователей" /></p>

<p>Рисунок &#95;&#95;PIC&#95;DB&#95;LAYER&#95;USERS&#95;&#95; – Слой пользователей</p>

<p>Данные о регионах (рисунок &#95;&#95;PIC&#95;DB&#95;LAYER&#95;REGIONS&#95;&#95;) содержат списки всех 
регионов Российской Федерации и населённых пунктов. С помощью внешних ключей 
между этими списками и паспортными данными установлена связь один-ко-многим.</p>

<p><img src="/images/db-layer-regions.png" alt="Слой регионов" /></p>

<p>Рисунок &#95;&#95;PIC&#95;DB&#95;LAYER&#95;REGIONS&#95;&#95; – Слой регионов</p>

<p>Слой заявок (рисунок &#95;&#95;PIC&#95;DB&#95;LAYER&#95;APPS&#95;&#95;) содержит 3 сущности: 
«Заявки», «История заявок» и «Платежи». В сущности «Заявки» содержатся 
идентификаторы, указывающие, какой пользователь на какую образовательную 
программу (или отдельную дисциплину из какой-либо программы) подал заявку. После 
подачи заявка проходит несколько стадий обработки. Сначала её должен одобрить 
администратор, после чего он прикрепляет к заявке договор (на файл договора 
указывает соответствующее поле). Слушатель должен подписать этот договор и 
произвести в соответствии с ним необходимую оплату. Оплата по одной заявке 
может быть произведена частями. Все эти изменения статуса заявки (подана, 
принята/отклонена, подписана, оплачена) отображаются в истории обработки заявок.</p>

<p><img src="/images/db-layer-apps.png" alt="Слой заявок" /></p>

<p>Рисунок &#95;&#95;PIC&#95;DB&#95;LAYER&#95;APPS&#95;&#95; – Слой заявок</p>

<p>В слое сообщений (рисунок &#95;&#95;PIC&#95;DB&#95;LAYER&#95;MSGS&#95;&#95;) находятся две сущности: «Сообщения» и «Прикреплённые файлы». 
Первая сущность содержит информацию о теме сообщения, его тексте, авторе 
сообщения, получателе и времени отправки сообщения. Кроме того, в этой сущности 
есть атрибут "прочитано", который представляет статус сообщения: было ли оно 
прочитано получателем или нет. Вторая сущность, «Прикреплённые файлы», 
необходима для реализации функции отправки файлов внутри сообщений. Она содержит 
данные о файле (имя файлы, тип) и идентификатор сообщения, к которому прикреплён 
данный файл.</p>

<p><img src="/images/db-layer-msgs.png" alt="Слой сообщений" /></p>

<p>Рисунок &#95;&#95;PIC&#95;DB&#95;LAYER&#95;MSGS&#95;&#95; – Слой сообщений</p>

<p>Слой учебных программ (рисунок &#95;&#95;PIC&#95;DB&#95;LAYER&#95;PROGRAMS&#95;&#95;) предназначен 
для хранения информации об учебных программах, дисциплинах, разделов и 
материалов. Каждая учебная программа имеет две типовые характеристики: специальность или 
курс, платная или бесплатная. Для каждой дисциплины установлена связь многие к 
одному с программами, для каждого раздела установлена аналогичная связь с 
дисциплиной. Помимо этого, разделы выстраиваются в иерархию родитель-потомок. 
Семантика этой иерархии заключается в следующем: пока не будет пройдена 
контрольная точка по родительскому разделу, доступ слушателю к дочернему разделу 
будет закрыт.</p>

<p><img src="/images/db-layer-programs.png" alt="Слой учебных программ" /></p>

<p>Рисунок &#95;&#95;PIC&#95;DB&#95;LAYER&#95;PROGRAMS&#95;&#95; – Слой учебных программ</p>

<p><img src="/images/db-model.png" alt="Концептуальная схема базы данных" /></p>

<p>Рисунок &#95;&#95;PIC&#95;DB&#95;MODEL&#95;&#95; – Концептуальная схема базы данных</p>

<p>Расмотрим подробнее слой пользователей, который имеет множество связей, как 
внутренних, так и внешних (с другими слоями) (рисунок &#95;&#95;PIC&#95;DB&#95;MODEL&#95;&#95;). Перечислим эти связи:</p>

<ul>
<li><p>ответственный преподаватель по программе, «Пользователи» – «Программы». Связь 
типа один-ко-многим, обозначает, какой преподаватель – ответственный за данную 
образовательную программу. Связь неидентифицирующая, допускает NULL-значения, 
поскольку для программы может быть ещё не назначен ответственный преподаватель;</p></li>
<li><p>ответственный преподаватель по дисциплине, «Пользователи» – «Дисциплины». 
Аналогична предыдущей связи, обозначет ответственного за данную дисциплину. 
Тип связи: один-ко-многим. Неидентифицирующая, допускает NULL-значения;</p></li>
<li><p>пользователь добавил материал, «Пользователи» – «Материалы». Связь типа 
один-ко-многим, обусловлена необходимостью сохранения указателя на 
пользователя, добавившего данный материал. Неидентифицирующая и не 
допускающая NULL-значений внешнего ключа, так как для каждого загружаемого 
материала обязательно запоминается тот, кто его добавляет;</p></li>
<li><p>заявка подана пользователем, «Пользователи» – «Заявки». Связь типа 
один-ко-многим, отражает соответствие заявке (на образовательную программу или 
дисциплину) пользователя, который это заявку подал. Так как любая заявка 
привязана к учётной записи пользователя, иначе она теряет смысл, то 
NULL-значения недопустимы. Связь неидентифицирующая;</p></li>
<li><p>пользователь отправил сообщение, «Пользователи» – «Сообщение». Связь типа 
один-ко-многим, указывает, какой пользователь отправил данное сообщение. Она 
неидентифицирующая и не допускает NULL-значений, так как у каждого сообщения 
обязательно есть отправитель;</p></li>
<li><p>сообщение для пользователя, «Пользователи» – «Сообщения». Связь типа 
один-ко-многим, указывает, для какого пользователя предназначено данное 
сообщение. Она неидентифицирующая и не допускает NULL-значений, так как для 
каждого сообщения обязательно указывается получатель;</p></li>
<li><p>телефоны слушателя, «Пользователи» – «Телефоны». Связь показывает, к какому 
пользователю относятся сведения о телефонах. Связь неидентифицирующая и не 
допускающая NULL-значений (все номера телефонов обязательны привязаны к 
учётной записи пользователя). Тип связи: один-к-одному;</p></li>
<li><p>документы слушателя, «Пользователи» – «Документы об образовании». Связь типа 
один-к-одному, показывает, к какому пользователю относятся сведения о 
документах об образовании. Связь неидентифицирующая и не допускающая 
NULL-значений (все документы обязательно относятся к какой-либо учётной 
записи);</p></li>
<li><p>паспортные данные слушателя, «Пользователи» – «Паспорта». Связь показывает, к 
какому пользователю относятся паспортные данные. Связь неидентифицирующая и не 
допускающая NULL-значений, потому что все паспортные данные привязаны к 
учётной записи пользователя. Тип связи: один-к-одному;</p></li>
<li><p>куратор слушателя, «Пользователи» – «Пользователи». Назначение этой связи - 
указывать, кто назначен куратором для данного слушателя. Тип: один-ко-многим. 
Связь неидентифицирующая и разрешает NULL-значения внешнего ключа, так как для 
слушателя куратор может быть назначен не сразу;</p></li>
<li><p>регион прописки, «Паспорта» – «Регионы». Связывает паспортные данные с 
регионом прописки. Неидентифицирующая и не допускает NULL-значений (сведения о 
прописке являются обязательными). Тип связи: один-ко-многим;</p></li>
<li><p>населённый пункт слушателя, «Паспорта» – «Населённые пункты». Связывает 
паспортные данные с населённым пунктом. Тип связи: один-ко-многим. 
Неидентифицирующая и не допускает NULL-значений, так как сведения о прописке 
являются обязательными;</p></li>
<li><p>населённый пункт из региона, «Населённые пункты» – «Регионы». Связь типа 
один-ко-многим, указывает, к какому региону относится тот или иной населённый 
пункт. Связь является неидентифицирующей и не допускает NULL-значения, потому 
что любой населённый пункт относится к какому-либо региону.</p></li>
</ul>

<h2>5. Общая архитектура системы</h2>

<p><img src="/images/arch-step-1.png" alt="Шаг 1" /></p>

<p>На первом шаге создаётся экземпляр менеджера ресурсов. Он предназначен для 
инициализации и обращения к различным активным элементами архитектуры (для 
простоты будем называть их ресурсами). Причём реальные экземпляры ресурсов 
создаются лишь в момент первого обращения к ним, а в дальнейшем ссылка на этот 
экземпляр сохраняется в менеджере. Таким образом реализуется механизм поздней 
загрузки, одновременно остающийся прозрачным для других частей системы и 
инкапсулированный внутри одной абстракции.</p>

<p>При создании менеджеру ресурсов передаётся конфигурация системы, то есть 
параметры настройки, влияющие на поведение системы в конкретном рабочем 
окружении. Перечислим эти параметры:</p>

<ul>
<li><p>режим работы системы;</p>

<p>позволяет выбирать режим функционирования системы: в режиме отладки или в 
рабочем режиме. Первый используется в процессе разработки - он позволяет 
выявлять ошибки в коде, отображая отладочную информацию о процессе работы 
системы (дерево вызовов, аргументы функций и методов и т.д.). Во втором 
режиме отладочная информация не отображается пользователям системы 
(поскольку её раскрытие посторонним с точки зрения безопасности 
функционирования сервера недопустимо), но записывается в специальный файл 
журнала, которой впоследствии может быть проанализирован системным 
администратором.</p></li>
<li><p>адрес сайта;</p>

<p>базовый адрес сайта, который будет в дальнейшем использоваться системой при 
генерации ссылок на сайте и в почтовых сообщениях, отправляемых 
пользователям.</p></li>
<li><p>настройки соединения с базой данных;</p>

<p>сюда входят такие параметры, как СУБД, с которой будет осушествляться 
работа, адрес сервера, имя пользователя, пароль. Допольнительно могут быть 
указаны опции, специфичные для какой-либо конкретной СУБД.</p></li>
<li><p>маршруты;</p>

<p>маршруты позволяют связывать запросы к веб-серверу с их непосредственными 
обработчиками в коде разрабатываемого приложения.</p></li>
<li><p>права доступа пользователей;</p>

<p>в зависимости от ролей пользователей в системе они имеют доступ к 
определённому набору страниц. Этот параметр служит для установления 
ассоциаций между ролями пользователей и обработчиками запросов (парами 
"контроллер-действие"), к которым пользователю разрешён доступ.</p></li>
<li><p>строка для шифрования данных авторизации;</p>

<p>пароли пользователей и некоторая другая информация, являющаяся 
чувствительной с точки зрения безопасности, сохраняется в базе с помощью 
необратимого алгоритма шифрования (хеширования), чтобы в случае, если 
потенциальный злоумышленник сможет считать такого рода информацию из базы 
данных, он не получил полного контроля над учётными записями пользователей. 
Для усиления хеш-функции применяется строка, состоящая из случайных 
символов, привносящая дополнительные степень неопределённость и, 
следовательно, стойкость к перебору в получаемые хеши.</p></li>
<li><p>настройки отправки почтовых сообщений.</p>

<p>в процессе работы с системой пользователям могут отправляться электронные 
почтовые сообщения. Данный параметр задаёт такие настройки, как используемый
для отправки транспорт (локальный агент передачи почты или удалённый 
SMTP-сервер), адрес и имя отправителя, данные для авторизации на 
SMTP-сервере (если выбран соответствующий транспорт).</p></li>
</ul>

<p>В целом, менеджер ресурсов представляет собой реализацию одной из форм активной 
инверсии зависимостей в коде, используемых при построении 
объектно-ориентированных систем. Эта форма называется "dependency lookup: pull 
approach" и предполагает наличие в системе общедоступного объекта, который 
знает обо всех используемых сервисах. Таким образом все зависимости 
инкапсулируются внутри этого объекта, и остальные части системы могут 
запрашивать по мере необходимости доступ к сервисам через него. [[1]]
[agiledev]</p>

<p><img src="/images/arch-step-2.png" alt="Шаг 2" /></p>

<p>На втором шаге создается экземпляр диспетчера запросов. Его предназначение 
состоит в том, чтобы при помощи маршрутизатора и сервиса авторизации 
делегировать управление необходимому в данный момент обработчику. Посколько 
система построена с использованием парадигмы MVC, то обработчиками запросов в 
данном случае выступают контроллеры, а точнее отдельные их действия.</p>

<pre><code>@todo Добавить ссылку на спеки HTTP.
</code></pre>

<p>Также диспетчер выполняет обработку ошибочных ситуаций, когда обработчик для 
текущего запроса не найден (код ошибки HTTP 404 - страница не найдена) и когда 
доступ текущему пользователю к обработчику запрещён (код ошибки 403 - доступ 
запрещён). В таких случаях управление будет передано специализированному 
контроллеру.</p>

<p><img src="/images/arch-step-3.png" alt="Шаг 3" /></p>

<p>Создаётся контейнер, содержащий практически всю информацию о запросе к 
веб-серверу. Сюда входят данные, переданные браузером пользователя 
HTTP-методами GET и POST, cookie (небольшие фрагменты данных, созданные
веб-сервером и хранимые на компьютере пользователя в виде файла, который 
веб-клиент, обычно веб-браузер, каждый раз пересылает веб-серверу в 
HTTP-запросе при попытке открыть страницу соответствующего сайта 
[[2]][cookie-wiki]) и переменные окружения веб-сервера. Такой контейнер создаёт 
дополнительный слой абстракции для системы, позволяя собрать зависимости 
различных частей от глобальных переменных, содержащих данные о запросе, в одной 
и поэтому легко контролируемой сущности. И этот контейнер передаётся для 
обработки диспетчеру запросов.</p>

<p><img src="/images/arch-step-4.png" alt="Шаг 4" /></p>

<p>На четвёртом шаге порождается экземпляр маршрутизатора, задачей которого 
является поиск среди настроенных в конфигурационных данных маршрута, шаблон 
которого совпадает с текущей запрашиваемой страницей, и определение 
необходимого обработчика.</p>

<p>Маршрут состоит из следующих полей данных:</p>

<ul>
<li><p>алиас;</p>

<p>краткое обозначение маршрута, используемое при генерации ссылок менеджером 
ссылок в коде контроллеров и шаблонов.</p></li>
<li><p>тип;</p>

<p>маршруты могут быть двух типов. Маршруты первого типа, статичные, задают 
однозначное соответствие между конкретным запрашиваемым адресом и 
соответствующмм обработчиком для него. Маршруты же второго типа, на основе 
регулярных выражений, позволяют дополнительно выделять из строки запроса 
отдельные параметры, передаваемые впоследствии контроллеру. Регулярные 
выражения - это формальный язык поиска и осуществления манипуляций с 
подстроками в тексте, основанный на использовании метасимволов (англ. 
wildcard characters). По сути это строка-образец (англ. pattern, по-русски 
её часто называют «шаблоном», «маской»), состоящая из символов и 
метасимволов и задающая правило поиска. [[3]][regex-wiki]</p></li>
<li><p>шаблон;</p>

<p>для маршрутов первого типа это строка, задающая точное значение 
запрашиваемого адреса, а для маршрутов второго - регулярное выражение и 
список названий для выделяемых параметров.</p></li>
<li><p>обработчик;</p>

<p>задаёт пару "контроллер-действие", которая будет выполнять непосредственную 
работу по выполнению запроса пользователя.</p></li>
<li><p>параметры.</p>

<p>для каждого марщрута (статического или с регулярным выражением) можно 
вручную задавать дополнительные параметры, которые будут передаваться в 
обработчик.                                                        </p></li>
</ul>

<p><img src="/images/arch-step-5.png" alt="Шаг 5" /></p>

<p>Диспетчер запросов проверяет, закрыт ли публичный доступ к запрашиваемой 
странице, и если да, то у менеджера ресурсов запрашивается ссылка на экземпляр 
сервис авторизации. С помощью него проверяется, авторизован ли пользователь в 
системе и какие права на доступ ему предоставлены. Если прав недостаточно для 
запрашиваемой странице, то диспетчер передаст управление не целевому 
контроллеру, а специализированному для обработки ошибки запрета доступа, который
выведет соответствующее сообщение об ошибке и предложит пользователю пройти 
авторизацию (если он не авторизован).</p>

<p>Сервис авторизации работает на основе механизма сессий. Cессии - это механизм, 
который позволяет создавать и использовать переменные, сохраняющие свое 
значение в течение всего времени работы пользователя с сайтом.</p>

<p>Эти переменные для каждого пользователя имеют различные значения и могут 
использоваться на любой странице сайта до выхода пользователя из системы. При 
этом каждый раз, заходя на сайт, пользователь получает новые значения 
переменных, позволяющие идентифицировать его в течение этого сеанса или сессии 
работы с сайтом. Отсюда и название механизма - сессии.</p>

<p>Задача идентификации пользователя решается путем присвоения каждому 
пользователю уникального номера, так называемого идентификатора сессии (SID, 
Session IDentifier). Он генерируется PHP в тот момент, когда пользователь 
заходит на сайт, и уничтожается, когда пользователь уходит с сайта, и 
представляет собой строку из 32 символов (например, 
ac4f4a45bdc893434c95dcaffb1c1811). Этот идентификатор передается на сервер 
вместе с каждым запросом клиента и возвращается обратно вместе с ответом 
сервера.</p>

<p>Алгоритм генерации SID (а в PHP в качестве идентификатора сессии используется 
т.н. GUID (Global Unique IDentifier)) позволяет гарантировать его уникальность, 
поэтому исключена возможность того, что две сессии будут иметь один и тот же 
идентификатор сессии.</p>

<p>Существует несколько способов передачи идентификатора сессии:</p>

<ul>
<li><p>с помощью cookies;</p>

<p>cookies были созданы специально как метод однозначной идентификации 
клиентов и представляют собой расширение протокола HTTP. В этом случае 
идентификатор сессии сохраняется во временном файле на компьютере клиента, 
пославшего запрос. Однако, многие пользователи отключают поддержку cookies 
на своем компьютере из-за проблем с безопасностью.</p></li>
<li><p>с помощью параметров командной строки.</p>

<p>в этом случае идентификатор сессии автоматически встраивается во все 
запросы (URL), передаваемые серверу, и хранится на стороне сервера. Этот 
способ передачи идентификатора используется автоматически, если у браузера, 
отправившего запрос, выключены cookies. Он достаточно надежный - передавать 
параметры в командной строке можно всегда. С другой стороны, идентификатор 
сессии можно украсть, воспользоваться сохраненным вариантом в строке 
браузера или попытаться подделать.</p></li>
</ul>

<p>[[7]][sessions-1], [[8]][sessions-2]</p>

<p><img src="/images/arch-step-6.png" alt="Шаг 6" /></p>

<p>После определения обработчика и проверки прав доступа диспетчер загружает код 
соответствующего класса контроллера и создаёт его экземпляр. После чего 
вместе со списком параметров передаёт управление одному из его методов, 
реализующих запрошенное действие.</p>

<p><img src="/images/arch-step-7.png" alt="Шаг 7" /></p>

<p>Контроллер выполняет запрошенное действие. В процессе он может инициализировать 
нужные модели и обращаться к ним. Модели служат для представления 
предметно-ориентированных данных и манипулирования ими. Основная их работа 
связана с объектом взаимодействия с базой данных, ссылку на которой они 
получают через менеджер ресурсов.</p>

<p>Объект для работы с базой данных основан на PHP Data Objects (PDO) — расширении 
для PHP, предоставляющее разработчику простой и универсальный интерфейс для 
доступа к различным базам данных.</p>

<p>PDO предлагает единые методы для работы с различными базами данных, хотя текст 
запросов может немного отличаться. Так как многие СУБД реализуют свой диалект 
SQL, который в той или иной мере поддерживает стандарты ANSI и ISO, то при 
использовании простых запросов можно добиться совместимости между различными 
языками. На практике это означает, что можно достаточно легко перейти на другую 
СУБД, при этом не меняя или частично изменяя код программы.</p>

<p>PDO не использует абстрактных слоёв для подключения к БД, наподобие ODBC, а 
использует для разных БД их «родные» драйверы, что позволяет добиться высокой 
производительности. В настоящее время для PDO существуют драйверы практически 
ко всем общеизвестным СУБД и интерфейсам. Впрочем, есть и драйвер для 
подключения к ODBC. </p>

<p>Также контроллер может создавать и работать с экземплярами вспомогательных 
классов, которые упрощают взаимодействие с HTML-формами.</p>

<p>Формы позволяют вводить текст, осуществлять выбор из предложенных значений при 
помощи списков или кнопок. С помощью форм можно организовать интерактивный 
обмен информацией между Web-страницей и сервером. Можно определить формы как 
электронные бланки для заполнения различных данных таких как, например, имя, 
возраст, выбор страны проживания и других. Как правило, форма работает 
совместно с установленным на сервере сценарным приложением, обрабатывающим 
введенную информацию. [[6]][forms]</p>

<p><img src="/images/arch-step-8.png" alt="Шаг 8" /></p>

<p>Помимо взаимодействий с моделями и обработчиками форм, контроллер может 
обращаться к сервису авторизации для получения данных текущего пользователя и 
реализации на их основе дополнительной логики обработки запросов.</p>

<p>А также контроллер может использовать менеджер ссылок. Он позволяет получать 
ссылки на различные страницы системы на основе данных маршрутов. Обращаясь к 
специальному методу менеджера ссылок и передавая ему алиас маршрута (для 
маршрутов на основе регулярных выражений может понадобиться ещё и передача 
списка значений параметров), можно получить ссылку на необходимую страницу, 
которая будет сформирована с учётом настроек системы. Таким образом, 
достигается гибкость системы в отношении её установки на сервере - все ссылки 
могут автоматически подстраиваться под рабочее окружение. Кроме того, сочетание 
маршрутов и использования в коде менеджера ссылок даёт возможность построения 
иерархии удобных и понятных адресов страниц на сайте.</p>

<p><img src="/images/arch-step-9.png" alt="Шаг 9" /></p>

<p>После завершения работы контроллер запрашивает у менеджера ресурсов объект 
представления, который занимается сборкой шаблонов, и ему передаётся управление 
вместе с набором переменных, который был сформирован во время выполнения 
действия контроллера и содержит необходимые для успешной обработки шаблонов 
данные.</p>

<p>После чего происходит сборка шаблонов трёх уровней и выдача пользователю 
сформированной страницы. К первому уровню относятся шаблоны страниц, 
ассоциированные с конкретными действиями запрошенного контроллера. На втором - 
шаблоны элементов, то есть частей страниц, которые повторяются в нескольких 
других шаблонах и поэтому могу быть выделены в отдельные файлы. И на третьем 
уровне - шаблон макета, содержащий общие для всех страниц части и выдача 
пользователю сформированной страницы.</p>

<p><img src="/images/arch-step-10.png" alt="Шаг 10" /></p>

<p>В процессе обработки шаблонов могут, как и в случае работы контроллеров, 
вызываться (через менеджер ресурсов) менеджер ссылок и объекты обработчиков 
форм, которые являются источниками необходимых для сборки выходных страниц 
данных.</p>

<h2>6. Роли пользователей в системе</h2>

<p>Разрабатываемая система подразумевает активное использование пользователями, 
доступ пользователей к разным частям системы с разными правами. Поэтому основные 
задачи подсистемы — управление доступом и учёт пользователей. Первая задача 
решается при помощи управления доступом на основе ролей. </p>

<p>Избирательное управление доступом (англ. Discretionary access control, DAC) — 
управление доступом субъектов к объектам на основе списков управления доступом 
или матрицы доступа.</p>

<p>Для каждой пары (субъект — объект) должно быть задано явное и недвусмысленное 
перечисление допустимых типов доступа (чтение, запись и т. д.), то есть тех 
типов доступа, которые являются санкционированными для данного субъекта 
(индивида или группы индивидов) к данному ресурсу (объекту)[[7]][fstec-protection].</p>

<p>Возможны несколько подходов к построению избирательного управления доступом:</p>

<ul>
<li><p>каждый объект системы имеет привязанного к нему субъекта, называемого 
владельцем. Именно владелец устанавливает права доступа к объекту.</p></li>
<li><p>система имеет одного выделенного субъекта — суперпользователя, который имеет 
право устанавливать права владения для всех остальных субъектов системы.</p></li>
<li><p>субъект с определенным правом доступа может передать это право любому другому 
субъекту[[8]][fstec-terms].</p></li>
</ul>

<p>Возможны и смешанные варианты построения, когда одновременно в системе 
присутствуют как владельцы, устанавливающие права доступа к своим объектам, так 
и суперпользователь, имеющий возможность изменения прав для любого объекта и 
(или) изменения его владельца. Именно такой смешанный вариант реализован в 
большинстве операционных систем, например, в классических UNIX-системах или в 
системах Windows семейства NT.</p>

<p>Избирательное управление доступом является основной реализацией 
разграничительной политики доступа к ресурсам при обработке конфиденциальных 
сведений, согласно требованиям к системе защиты информации.</p>

<p>Управление доступом на основе ролей (англ. Role Based Access Control, RBAC) — 
развитие политики избирательного управления доступом, при этом права доступа 
субъектов системы на объекты группируются с учетом специфики их применения, 
образуя роли.</p>

<p>Формирование ролей призвано определить четкие и понятные для пользователей 
компьютерной системы правила разграничения доступа. Ролевое разграничение 
доступа позволяет реализовать гибкие, изменяющиеся динамически в процессе 
функционирования компьютерной системы правила разграничения доступа.</p>

<p>Такое разграничение доступа является составляющей многих современных 
компьютерных систем. Как правило, данный подход применяется в системах защиты 
СУБД, а отдельные элементы реализуются в сетевых операционных системах. Ролевой 
подход часто используется в системах, для пользователей которых четко определен 
круг их должностных полномочий и обязанностей.</p>

<p>Несмотря на то, что роль является совокупностью прав доступа на объекты 
компьютерной системы, ролевое управление доступом отнюдь не является частным 
случаем избирательного управления доступом, так как его правила определяют 
порядок предоставления доступа субъектам компьютерной системы в зависимости от 
имеющихся (или отсутствующих) у него ролей в каждый момент времени, что является 
характерным для систем мандатного управления доступом. С другой стороны, правила 
ролевого разграничения доступа являются более гибкими, чем при мандатном подходе 
к разграничению.</p>

<p>Так как привилегии не назначаются пользователям непосредственно, и приобретаются 
ими только через свою роль (или роли), управление индивидуальными правами 
пользователя по сути сводится к назначению ему ролей. Это упрощает такие 
операции, как добавление пользователя или смена подразделения пользователем.
[[9]][roles-wiki]</p>

<p>В системе предусмотрено три возможных роли для пользователей:</p>

<ul>
<li>администраторы;</li>
<li>преподаватели;</li>
<li>слушатели.</li>
</ul>

<p>Опишем действия, которые может осуществляет пользователь с ролью «администратор» 
(рисунок &#95;&#95;PIC&#95;ADMIN&#95;USE_CASES&#95;&#95;):</p>

<ul>
<li>регистрирует новых сотрудников (администраторов и преподавателей);</li>
<li>формирует структуру образовательных программ;</li>
<li>добавляет материалы в образовательные программы;</li>
<li>назначает ответственных за дисциплины/курсы преподавателей;</li>
<li>назначает кураторов для слушателей;</li>
<li>обрабатывает заявки слушателей;</li>
<li>регистрирует платежи слушателей.</li>
</ul>

<p><img src="/images/admin-use-cases.png" alt="Диаграмма прецедентов администратора" /></p>

<p>Рисунок &#95;&#95;PIC&#95;ADMIN&#95;USE_CASES&#95;&#95; – Диаграмма прецедентов администратора</p>

<p>Действия, осуществляемые пользователем с ролью «преподаватель» (рисунок 
&#95;&#95;PIC&#95;TEACHER&#95;USE&#95;CASES&#95;&#95;):</p>

<ul>
<li>добавляет материалы в образовательные программы;</li>
<li>общается со слушателями, руководит учебным процессом;</li>
<li>проверяет контрольные задания.</li>
</ul>

<p><img src="/images/teacher-use-cases.png" alt="Диаграмма прецедентов преподавателя" /></p>

<p>Рисунок &#95;&#95;PIC&#95;TEACHER&#95;USE&#95;CASES&#95;&#95; – Диаграмма прецедентов преподавателя </p>

<p>И действия, которые осуществляются пользователем с ролью «слушатель» (рисунок 
&#95;&#95;PIC&#95;STUDENT&#95;USE_CASES&#95;&#95;):</p>

<ul>
<li>подаёт заявки на образовательные программы;</li>
<li>просматривает материалы образовательных программ;</li>
<li>общается с преподавателями/куратором;</li>
<li>выполняет контрольные задания.</li>
</ul>

<p><img src="/images/student-use-cases.png" alt="Диаграмма прецедентов слушателя" /></p>

<p>Рисунок  &#95;&#95;PIC&#95;STUDENT&#95;USE&#95;CASES&#95;&#95; – Диаграмма прецедентов слушателя</p>

<h2>7. Регистрация пользователей</h2>

<p>Процесс регистрации предназначен для внесения в систему данных о новом 
пользователе, определения его прав на доступ к различным частям системы и 
назначения ему внутреннего идентификатора.</p>

<p>Регистрация слушателей осуществляется самими пользователями, желающими пройти 
обучение. В то время, как регистрация сотрудников в системе производится 
администратором.</p>

<p>За регистрацию сотрудников отвечает метод Controller&#95;Users::action&#95;register&#95;employee().
При помощи класса формы Form&#95;Profile&#95;Employee&#95;Registration он получает данные от 
браузера пользователя и проводит их валидацию.</p>

<p>При регистрации администратора заполняются следующие поля формы:</p>

<ul>
<li>фамилия;</li>
<li>имя;</li>
<li>отчество;</li>
<li>логин;</li>
<li>адрес электронной почты.</li>
</ul>

<p>Если данные проходят проверку, то создаётся экземпляр модели для работы с пользователями, 
и данные передаются вместе с ролью нового пользователя в метод Model&#95;User::register().
Данный метод выполняет подготовку выражения запроса на добавление новой записи пользователя 
в базу данных:</p>

<pre><code>INSERT INTO users
(login, passwd, role, email, surname, name, patronymic, status)
VALUES
(:login, :passwd, :role, :email, :surname, :name, :patronymic, :status) 
</code></pre>

<p>Подготовленные выражения предоставляют разработчикам возможность создавать 
запросы, которые являются более безопасными, имеют более высокую 
производительность и более удобны в написании.</p>

<p>Подготовленные выражения с заданными параметрами позволяют создавать шаблоны 
запросов и хранить их на сервере СУБД. Когда нужно создать запрос, данные, 
заполняющие шаблон, отправляются серверу MySQL, где полностью сформированный 
запрос и выполняется.</p>

<p>Основной процесс создания и использования подготовленных выражений с заданными 
параметрами прост. Создается шаблон запроса и посылается серверу СУБД. Сервер 
его получает, проверяет его корректность, чтобы убедиться, что он имеет смысл, 
и сохраняет его в специальном буфере. Затем сервер возвращает идентификатор, 
который может быть в дальнейшем использован для обращения к подготовленному выражению.</p>

<p>Когда нужно создать запрос, данные, заполняющие шаблон, отправляются серверу 
СУБД и полностью сформированный запрос выполняется.</p>

<p>Таким образом, тело шаблона отсылается серверу СУБД только один раз. Для 
выполнения выражения посылаются только данные, необходимые для заполнения шаблона.
Большая часть работы по проверке и обработке запроса проделывается только один 
раз, вместо того, чтобы делать это каждый раз.</p>

<p>Данные запроса не должны проходить через функции экранирования потенциально 
опасных символов, чтобы убедиться, что нет угрозы атаки типа "SQL-injection". 
Вместо этого, клиент и сервер СУБД работают так, чтобы убедиться, что посланные 
данные безопасно обработаны при их комбинировании с подготовленным выражением.
[[4]][prepared-stmt]</p>

<p>Затем модель шифрует пароль необратимым методом для дополнительной безопасти. 
Для этого через менеджер ресурсов модель получает ссылку на экземпляр сервиса 
авторизации и вызывает метод Auth::getPasswdHash(), передавая ему строку с 
паролем. Этот метод производит хеширование пароля алгоритмом MD5 
в несколько раундов и с применением случайной последовательности символов, что 
даёт усиление защиты от взлома при помощи радужных таблиц.</p>

<p>MD5 (англ. Message Digest 5) — 128-битный алгоритм хеширования, разработанный 
профессором Рональдом Л. Ривестом из Массачусетского технологического института 
(Massachusetts Institute of Technology, MIT) в 1991 году. Предназначен для 
создания «отпечатков» или «дайджестов» сообщений произвольной длины. Зная 
MD5-образ (называемый также MD5-хеш или MD5-дайджест), невозможно восстановить 
входное сообщение. Используется для проверки подлинности опубликованных 
сообщений путём сравнения дайджеста сообщения с опубликованным. Эту операцию 
называют «проверка хеша». </p>

<p>На данный момент существуют несколько видов «взлома» хешей MD5 — подбора 
сообщения с заданным хешем. Один из таких методов —  радужные таблицы (англ. 
rainbow table). [[6]][md5-wiki]. Радужная таблица — специальный вариант таблиц 
поиска (англ. lookup table), использующий механизм уменьшения времени поиска за 
счет увеличения занимаемой памяти или time-memory tradeoff. Радужные таблицы 
используются для вскрытия паролей, преобразованных при помощи необратимой 
хеш-функции.</p>

<p>Радужная таблица создается построением цепочек возможных паролей. Каждая цепочка 
начинается со случайного возможного пароля, затем подвергается действию 
хеш-функции и функции редукции. Данная функция преобразует результат хеш-функции 
в некоторый возможный пароль. Промежуточные пароли в цепочке отбрасываются и в 
таблицу записывается только первый и последний элементы цепочек. Создание таблиц 
требует времени и памяти (вплоть до сотен гигабайт), но они позволяют очень 
быстро (по сравнению с обычными методами) восстановить исходный пароль.</p>

<p>Для восстановления пароля данное значение хеш-функции подвергается функции 
редукции и ищется в таблице. Если не было найдено совпадения, то снова 
применяется хеш-функция и функция редукции. Данная операция продолжается, пока 
не будет найдено совпадение. После нахождения совпадения, цепочка содержащая 
его, восстанавливается для нахождения отброшенного значения, которое и будет 
искомым паролем. [[5]][rainbow-tables-wiki]</p>

<p>В итоге получается таблица, которая может с высокой вероятностью восстановить 
пароль за небольшое время.</p>

<p>После вычисления хеша пароля он вместе с другим набором данных передаётся в объект 
взаимодействия с СУБД для выполнения с ранее подготовленным запросом. Затем на 
указанный адрес электронной почты
пользователю отправляется сообщение, в котором содержится ссылка для активации 
созданной учётной записи.</p>

<p>Процесс регистрации преподавателя аналогичен регистрации администратора, но 
создаётся запись о пользователе с другой ролью и, соответственно, с другим набором прав в 
системе.</p>

<p>Процесс регистрации слушателя делится на два этапа: первичная регистрация и 
вторичная. За регистрацию слушателей отвечает метод Controller&#95;Users::action&#95;register&#95;student().
В ходе первичной регистрации указываются только базовые поля данных пользователя 
(базовый профиль):</p>

<ul>
<li>логин;</li>
<li>пароль;</li>
<li>адрес электронной почты.</li>
</ul>

<p>Поэтому в коде данного действия используется другой класс формы, нежели чем при 
регистрации сотрудника, — Form&#95;Profile&#95;Student&#95;Registration. Аналогично 
описанному выше процессу регистрации сотрудника происходит получение данных от 
браузера, их валидации, сохранение в базе данных (с тем отличием, что при 
добавлении записи в базу используется значение поля роли Model_User::ROLE&#95;STUDENT,
то есть — слушатель) и отправкой новому слушателю на указанный адрес электронной 
почты уведомления, в котором содержится ссылка для активации учётной записи. </p>

<p>После первичной регистрации слушатель может получить доступ только к бесплатным 
образовательным программам. Для того, чтобы получить доступ к платным программам, 
пользователь должен пройти вторичную регистрацию, в ходе которой требуется ввести 
в систему подробную информацию о себе (расширенный профиль):</p>

<ul>
<li>фамилия;</li>
<li>имя;</li>
<li>отчество;</li>
<li>дата рождения (в формате дд.мм.гггг);</li>
<li>паспортные данные:

<ul>
<li>серия (4-ре цифры);</li>
<li>номер (6-ть цифр);</li>
<li>прописка:

<ul>
<li>область/край;</li>
<li>город;</li>
<li>улица;</li>
<li>дом/корпус;</li>
<li>квартира/комната.</li>
</ul></li>
</ul></li>
<li>сведения об имеющемся образовании:

<ul>
<li>вид документа (диплом о высшем образовании, диплом о среднем 
профессиональном образовании или иное);</li>
<li>номер документа;</li>
<li>год окончания;</li>
<li>специальность;</li>
<li>квалификация.</li>
</ul></li>
<li>контактные телефоны:

<ul>
<li>мобильный;</li>
<li>домашний/рабочий (стационарный).</li>
</ul></li>
</ul>

<p>Процесс вторичной регистрации реализует метод-действие Controller&#95;Users::action&#95;profile&#95;extended() 
и, соответственно, ещё один класс формы Form&#95;Profile&#95;Student&#95;Extended. Данные 
действие контроллера и класс формы предоставляют интерфейс просмотра и 
редактирования расширенного профиля слушателя. Если этот профиль пуст, как в 
случае с вновь зарегистрированным пользователем, то ему будет показана форма с 
пустыми полями и предложением её заполнить. Если же профиль уже был заполнен 
ранее, то форма будет заполнена введёнными данными. Слушатель может их 
скорректировать при необходимости и сохранить.</p>

<p>Поскольку форма содержит довольно большое число полей, для упрощения их обработки 
внутри системы используются специализированные классы-контейнеры: Model&#95;User&#95;Passport, 
Model&#95;User&#95;EduDoc и Model&#95;User&#95;Phones, служащие для хранения, соответственно, 
паспортных данных, данных о документе об образовании и данных о телефонах 
пользователя. Сами классы содержат перечисления полей и ассоциации между полями 
формы и полями в базе данных. Но они наследуют от абстрактного класса Model&#95;User&#95;Abstract 
методы, которые и делают непосредственно работу по обслуживанию данных. 
Перечислим эти методы:</p>

<ol>
<li>Model&#95;User&#95;Abstract::fromRow(), служит для заполнение контейнера 
данными из записи базы данных, параметром для него является массив 
значений полей;</li>
<li>Model&#95;User&#95;Abstract::fromForm(), сохраняет в контейнере информацию из 
формы расширенного профиля слушателя, параметр - объект класса 
Form&#95;Profile&#95;Student&#95;Extended;</li>
<li>Model&#95;User&#95;Abstract::toForm(), заполняет поля формы данными из 
контейнера, параметром является также объект класса 
Form&#95;Profile&#95;Student&#95;Extended.</li>
</ol>

<p>После заполнения контейнера к его полям можно обращаться, как к свойствам 
(атрибутам) класса. При обновлении данных расширенного профиля слушателя три 
этих заполненных на основе формы контейнера передаются методам модели 
пользователя: Model&#95;User::savePassport(), Model&#95;User::saveEduDoc() и 
Model&#95;User::savePhones(). Эти методы в качестве первого параметра принимают 
идентификатор пользователя, указывающий для какого слушателя производится 
обновление записи, и соответствующий методу контейнер.</p>

<p>Для реализации просмотра администратором расширенного профиля слушателя (а 
именно администратор на основании в том числе данных профиля принимает решение о 
предоставлении допуска слушателю к желаемым образовательным программам)<br />
используется действие контроллера Controller&#95;Users::action&#95;view&#95;profile(). Этот 
метод создаёт экземпляр модели для работы с пользователями и при помощи метода 
Model&#95;User::getExtendedProfile() получает массив с тремя описанными выше 
контейнерами, содержащими требуемую информацию, и передаёт их шаблону отображения 
для вывода пользователю.</p>

<p>Использование такого рода контейнеров для обработки данных повышает гибкость 
кода, улучшает читаемость кода и повышает скорость дальнейшей 
разработки в случае модификации и/или доработки логики работы с профилями 
слушателей.</p>

<h2>8. Авторизация и контроль прав доступа</h2>

<p>Авторизация (англ. authorization) — процесс, а также результат процесса проверки 
необходимых параметров и предоставление определённых полномочий лицу или группе 
лиц (прав доступа) на выполнение некоторых действий в различных системах с 
ограниченным доступом. [[1]][otvet-mail-auth]</p>

<p>Следует различать авторизацию и аутентификацию: аутентификация — это 
установление подлинности лица, а авторизация — предоставление этому лицу 
некоторых прав или проверка их наличия (как правило — следующий шаг системы 
после аутентификации). [[3]][auth-wiki]</p>

<p>Авторизация пользователей в системе реализуется при помощи метода 
Controller&#95;Users::action&#95;login(). Используя вспомогательный класс обработчика 
форм Form&#95;Profile&#95;Login, он получает введённые пользователем логин и пароль. 
Далее инициализируется экземпляр класса-модели Model&#95;User и управление передаётся 
методу Model&#95;User::login(). Данный метод модели подготавливает для выполнения 
следующий запрос на проверку существования указанного пользователя и соответствия 
пароля:</p>

<pre><code>SELECT *
FROM  users
WHERE login = :login AND
      passwd = :passwd
</code></pre>

<p>После чего через менеджер ресурсов модель получает ссылку на экземпляр сервиса 
авторизации Auth и с помощью метода Auth::getPasswdHash() вычисляет хеш пароля 
(поскольку в базе все пароли хранятся в хешированном виде, как было сказано ранее 
в описании процесса регистрации пользователей). И пара «логин, хеш пароля» 
передаётся для выполнения в подготовленный запрос.</p>

<p>После выполнения запроса модель пытается считать результат запроса. Если это не 
удаётся, то есть запрос не вернул записей, метод возвращает код ошибки, сообщающий, 
что пользователь не найден (Model&#95;User::ERR&#95;USER&#95;NOT&#95;FOUND). Если же 
пользователь найден, но у него установлен статус, обозначающий, что учётная 
запись ещё не активирована, то возвращается код ошибки "пользователь не активен" 
(Model&#95;User::ERR&#95;USER&#95;INACTIVE). Иначе, через сервис авторизации инициализируется 
новая сессия и через метода Auth::setUserId() в ней сохраняется идентификатор 
текущего авторизованного пользователя, и модель возвращает данные пользователя.</p>

<p>Если контроллер получил из модели код ошибки, то пользователю выдаётся 
соответствующее предупреждение. А если авторизация прошла успешно, браузер пользователя 
перенаправляется на заданную для роли пользователя страницу.</p>

<p>Снятие авторизации происходит через действие контроллера Controller&#95;Users::action&#95;logout(), 
который с помощью модели для работы с пользователями и сервиса авторизации стирает 
из сессии идентификатор учётной записи пользователя (метод Auth::unsetUserId()).</p>

<p>Для реализации политики управления доступом на основе ролей используется 
интерфейс, предоставляемый моделью для работы с данными пользователей Model&#95;User.
Этот интерфейс служит для проверки авторизации и получения сведений учётной записи авторизованного 
пользователя. Вызывая метод Model&#95;User::getAuth(), другие контроллеры и модели 
могут релизовывать бизнес-логику, требующую ограничения доступа по отношению к 
каким-либо операциям. Метод запрашивает у сервиса авторизации идентификатор 
пользователя через метод Auth::getUserId(). По этому идентификатору модель 
подгружает из базы данных данные учётной записи и возвращает их. Если 
пользователь не авторизован, то будет возвращено булево значение false. Таким 
образом в коде можно реализовывать проверку на соответствие роли пользователя, 
его прав запрашиваемому ресурсу или операции.</p>

<p>Кроме того, диспетчер запросов Mvc_Dispatcher в автоматическом режиме может 
производить контроль доступа к действиям контроллеров на основе ролей 
пользователей. При обработке запросов он получает данные текущего 
авторизованного пользователя и, сверяясь со списком прав доступа, разрешает или 
запрещает доступ к запрашиваемой странице. Список прав доступа - это раздел 
конфигурации, который содержит однозначные ассоциации между ролями пользователей 
и действиями контроллеров, к которым им разрешён доступ. Действия, не 
перечисленные в этом списке, считаются доступными всем пользователям.</p>

<h2>9. Экономическая эффективность</h2>

<p>Одним из важных этапов разработки программных систем является количественная и качественная оценка предполагаемых эффектов от внедрения проектируемой системы, основным из которых является экономический эффект.
Под экономическим эффектом понимается превышение стоимостной оценки результатов, получаемых при использовании новых методов, алгоритмов, программ, аппаратуры, используемых в системах (подсистемах), основанных на базе ЭВМ, над стоимостной оценкой совокупных затрат ресурсов за весь срок разработки и использования предлагаемых для внедрения элементов названных систем (подсистем). Одним из частных показателей эффективности является производительность труда.
Наряду с основным возникают и сопутствующие виды эффектов, к которым относятся следующие: научный, организационный, социальный и экологический.
Научный эффект предполагает создание новых теорий, научных основ, закономерностей, научных идей, гипотез, новых методов исследований и измерений, решение новых задач.
Организационный эффект предполагает разработку новых форм и методов организации производства и обслуживания, управления и труда.
Социальный эффект включает в себя повышение материального благосостояния и культурного уровня народа, изменение характера и улучшение условий труда, повышение уровня образования, увеличение средней продолжительности жизни и свободного времени, уменьшение вредного влияния техники и производства и так далее.
Экологический эффект предусматривает улучшение параметров окружающей среды, разработку проектов новых природоохранных мероприятий, замену дефицитных материалов и другое.
После начала использования проектируемой нами системы следует ожидать получения экономического, организационного и социального эффектов.
Организационный эффект возникает в результате внедрения новой методики обучения – дистанционное образование предполагает методы передачи и проверки знаний, отличные от тех, которые применяются при традиционных способах обучения.
Социальный эффект возникает в связи с повышением уровня образования и квалификации обучающихся. Это связано с тем, что очная форма образования не подходит для ряда граждан по причине нехватки времени, тогда как дистанционное образование позволяет пройти обучения без отрыва от основной деятельности.</p>

<p>@TODO</p>

      </div>
      </div>
 
      <div class="push"></div>
    </div>
 
    <div id="footer">
      <div class="site">
 
        <div class="info">
          <div class="links">
            <a href="http://github.com/blog/148-github-shirts-now-available">T-Shirts</a> |
            <a href="http://github.com/blog">Blog</a> |
            <a href="http://support.github.com/">Support</a> |
            <a href="http://github.com/training">Git Training</a> |
            <a href="http://github.com/contact">Contact</a> |
            <a href="http://groups.google.com/group/github/">Google Group</a> |
            <a href="http://github.wordpress.com">Status</a>
          </div>
          <div class="company">
            GitHub is <a href="http://logicalawesome.com/">Logical Awesome</a> &copy;2009 | <a href="http://github.com/site/terms">Terms of Service</a> | <a href="http://github.com/site/privacy">Privacy Policy</a>
          </div>
        </div>
        <div class="sponsor">
          <div>
            Powered by the <a href="http://www.rackspace.com ">Dedicated
            Servers</a> and<br/> <a href="http://www.rackspacecloud.com">Cloud
            Computing</a> of Rackspace Hosting<span>&reg;</span>
          </div>
          <a href="http://www.rackspace.com">
            <img src="/images/modules/footer/rackspace_logo.png" alt="Dedicated Server" />
          </a>
        </div>
      </div>
    </div>
 
  </body>
</html>